import "./chunk-ZSMWDLMK.js";

// node_modules/maska/dist/maska.mjs
var P = Object.defineProperty;
var C = (n, s, t) => s in n ? P(n, s, { enumerable: true, configurable: true, writable: true, value: t }) : n[s] = t;
var y = (n, s, t) => C(n, typeof s != "symbol" ? s + "" : s, t);
var N = {
  "#": { pattern: /[0-9]/ },
  "@": { pattern: /[a-zA-Z]/ },
  "*": { pattern: /[a-zA-Z0-9]/ }
};
var R = (n, s, t) => n.replaceAll(s, "").replace(t, ".").replace("..", ".").replace(/[^.\d]/g, "");
var I = (n, s, t) => {
  var e;
  return new Intl.NumberFormat(((e = t.number) == null ? void 0 : e.locale) ?? "en", {
    minimumFractionDigits: n,
    maximumFractionDigits: s,
    roundingMode: "trunc"
  });
};
var F = (n, s = true, t) => {
  var M, E, g, d;
  const e = ((M = t.number) == null ? void 0 : M.unsigned) == null && n.startsWith("-") ? "-" : "", a = ((E = t.number) == null ? void 0 : E.fraction) ?? 0;
  let o = I(0, a, t);
  const h = o.formatToParts(1000.12), p = ((g = h.find((r) => r.type === "group")) == null ? void 0 : g.value) ?? " ", f = ((d = h.find((r) => r.type === "decimal")) == null ? void 0 : d.value) ?? ".", i = R(n, p, f);
  if (i === "" || Number.isNaN(i)) return e;
  const u = i.split(".");
  if (u[1] != null && u[1].length >= 1) {
    const r = u[1].length <= a ? u[1].length : a;
    o = I(r, a, t);
  }
  let l2 = o.format(parseFloat(i));
  return s ? a > 0 && i.endsWith(".") && !i.slice(0, -1).includes(".") && (l2 += f) : l2 = R(l2, p, f), e + l2;
};
var T = class {
  constructor(s = {}) {
    y(this, "opts", {});
    y(this, "memo", /* @__PURE__ */ new Map());
    const t = { ...s };
    if (t.tokens != null) {
      t.tokens = t.tokensReplace ? { ...t.tokens } : { ...N, ...t.tokens };
      for (const e of Object.values(t.tokens))
        typeof e.pattern == "string" && (e.pattern = new RegExp(e.pattern));
    } else
      t.tokens = N;
    Array.isArray(t.mask) && (t.mask.length > 1 ? t.mask = [...t.mask].sort((e, a) => e.length - a.length) : t.mask = t.mask[0] ?? ""), t.mask === "" && (t.mask = null), this.opts = t;
  }
  masked(s) {
    return this.process(s, this.findMask(s));
  }
  unmasked(s) {
    return this.process(s, this.findMask(s), false);
  }
  isEager() {
    return this.opts.eager === true;
  }
  isReversed() {
    return this.opts.reversed === true;
  }
  completed(s) {
    const t = this.findMask(s);
    if (this.opts.mask == null || t == null) return false;
    const e = this.process(s, t).length;
    return typeof this.opts.mask == "string" ? e >= this.opts.mask.length : e >= t.length;
  }
  findMask(s) {
    const t = this.opts.mask;
    if (t == null)
      return null;
    if (typeof t == "string")
      return t;
    if (typeof t == "function")
      return t(s);
    const e = this.process(s, t.slice(-1).pop() ?? "", false);
    return t.find((a) => this.process(s, a, false).length >= e.length) ?? "";
  }
  escapeMask(s) {
    const t = [], e = [];
    return s.split("").forEach((a, o) => {
      a === "!" && s[o - 1] !== "!" ? e.push(o - e.length) : t.push(a);
    }), { mask: t.join(""), escaped: e };
  }
  process(s, t, e = true) {
    if (this.opts.number != null) return F(s, e, this.opts);
    if (t == null) return s;
    const a = `v=${s},mr=${t},m=${e ? 1 : 0}`;
    if (this.memo.has(a)) return this.memo.get(a);
    const { mask: o, escaped: h } = this.escapeMask(t), p = [], f = this.opts.tokens != null ? this.opts.tokens : {}, i = this.isReversed() ? -1 : 1, u = this.isReversed() ? "unshift" : "push", l2 = this.isReversed() ? 0 : o.length - 1, M = this.isReversed() ? () => r > -1 && c2 > -1 : () => r < o.length && c2 < s.length, E = (k2) => !this.isReversed() && k2 <= l2 || this.isReversed() && k2 >= l2;
    let g, d = -1, r = this.isReversed() ? o.length - 1 : 0, c2 = this.isReversed() ? s.length - 1 : 0, b = false;
    for (; M(); ) {
      const k2 = o.charAt(r), m = f[k2], v = (m == null ? void 0 : m.transform) != null ? m.transform(s.charAt(c2)) : s.charAt(c2);
      if (!h.includes(r) && m != null ? (v.match(m.pattern) != null ? (p[u](v), m.repeated ? (d === -1 ? d = r : r === l2 && r !== d && (r = d - i), l2 === d && (r -= i)) : m.multiple && (b = true, r -= i), r += i) : m.multiple ? b && (r += i, c2 -= i, b = false) : v === g ? g = void 0 : m.optional && (r += i, c2 -= i), c2 += i) : (e && !this.isEager() && p[u](k2), v === k2 && !this.isEager() ? c2 += i : g = k2, this.isEager() || (r += i)), this.isEager())
        for (; E(r) && (f[o.charAt(r)] == null || h.includes(r)); ) {
          if (e) {
            if (p[u](o.charAt(r)), s.charAt(c2) === o.charAt(r)) {
              r += i, c2 += i;
              continue;
            }
          } else o.charAt(r) === s.charAt(c2) && (c2 += i);
          r += i;
        }
    }
    return this.memo.set(a, p.join("")), this.memo.get(a);
  }
};
var w = (n) => JSON.parse(n.replaceAll("'", '"'));
var x = (n, s = {}) => {
  const t = { ...s };
  n.dataset.maska != null && n.dataset.maska !== "" && (t.mask = W(n.dataset.maska)), n.dataset.maskaEager != null && (t.eager = A(n.dataset.maskaEager)), n.dataset.maskaReversed != null && (t.reversed = A(n.dataset.maskaReversed)), n.dataset.maskaTokensReplace != null && (t.tokensReplace = A(n.dataset.maskaTokensReplace)), n.dataset.maskaTokens != null && (t.tokens = O(n.dataset.maskaTokens));
  const e = {};
  return n.dataset.maskaNumberLocale != null && (e.locale = n.dataset.maskaNumberLocale), n.dataset.maskaNumberFraction != null && (e.fraction = parseInt(n.dataset.maskaNumberFraction)), n.dataset.maskaNumberUnsigned != null && (e.unsigned = A(n.dataset.maskaNumberUnsigned)), (n.dataset.maskaNumber != null || Object.values(e).length > 0) && (t.number = e), t;
};
var A = (n) => n !== "" ? !!JSON.parse(n) : true;
var W = (n) => n.startsWith("[") && n.endsWith("]") ? w(n) : n;
var O = (n) => {
  if (n.startsWith("{") && n.endsWith("}"))
    return w(n);
  const s = {};
  return n.split("|").forEach((t) => {
    const e = t.split(":");
    s[e[0]] = {
      pattern: new RegExp(e[1]),
      optional: e[2] === "optional",
      multiple: e[2] === "multiple",
      repeated: e[2] === "repeated"
    };
  }), s;
};
var L = class {
  constructor(s, t = {}) {
    y(this, "items", /* @__PURE__ */ new Map());
    y(this, "onInput", (s2) => {
      if (s2 instanceof CustomEvent && s2.type === "input")
        return;
      const t2 = s2.target, e = this.items.get(t2), a = "inputType" in s2 && s2.inputType.startsWith("delete"), o = e.isEager(), h = a && o && e.unmasked(t2.value) === "" ? "" : t2.value;
      this.fixCursor(t2, a, () => this.setValue(t2, h));
    });
    this.options = t, this.init(this.getInputs(s));
  }
  update(s = {}) {
    this.options = { ...s }, this.init(Array.from(this.items.keys()));
  }
  updateValue(s) {
    s.value !== "" && s.value !== this.processInput(s).masked && this.setValue(s, s.value);
  }
  destroy() {
    for (const s of this.items.keys())
      s.removeEventListener("input", this.onInput);
    this.items.clear();
  }
  init(s) {
    const t = this.getOptions(this.options);
    for (const e of s) {
      this.items.has(e) || e.addEventListener("input", this.onInput, { capture: true });
      const a = new T(x(e, t));
      this.items.set(e, a), queueMicrotask(() => this.updateValue(e)), e.selectionStart === null && a.isEager() && console.warn("Maska: input of `%s` type is not supported", e.type);
    }
  }
  getInputs(s) {
    return typeof s == "string" ? Array.from(document.querySelectorAll(s)) : "length" in s ? Array.from(s) : [s];
  }
  getOptions(s) {
    const { onMaska: t, preProcess: e, postProcess: a, ...o } = s;
    return o;
  }
  fixCursor(s, t, e) {
    const a = s.selectionStart, o = s.value;
    if (e(), a === null || a === o.length && !t) return;
    const h = s.value, p = o.slice(0, a), f = h.slice(0, a), i = this.processInput(s, p).unmasked, u = this.processInput(s, f).unmasked;
    let l2 = a;
    p !== f && (l2 += t ? h.length - o.length : i.length - u.length), s.setSelectionRange(l2, l2);
  }
  setValue(s, t) {
    const e = this.processInput(s, t);
    s.value = e.masked, this.options.onMaska != null && (Array.isArray(this.options.onMaska) ? this.options.onMaska.forEach((a) => a(e)) : this.options.onMaska(e)), s.dispatchEvent(new CustomEvent("maska", { detail: e })), s.dispatchEvent(new CustomEvent("input", { detail: e.masked }));
  }
  processInput(s, t) {
    const e = this.items.get(s);
    let a = t ?? s.value;
    this.options.preProcess != null && (a = this.options.preProcess(a));
    let o = e.masked(a);
    return this.options.postProcess != null && (o = this.options.postProcess(o)), {
      masked: o,
      unmasked: e.unmasked(a),
      completed: e.completed(a)
    };
  }
};

// node_modules/maska/dist/vue.mjs
var l = /* @__PURE__ */ new WeakMap();
var c = (e, s) => {
  if (e.arg == null || e.instance == null) return;
  const a = "setup" in e.instance.$.type;
  e.arg in e.instance ? e.instance[e.arg] = s : a && console.warn("Maska: please expose `%s` using defineExpose", e.arg);
};
var k = (e, s) => {
  var u;
  const a = e instanceof HTMLInputElement ? e : e.querySelector("input");
  if (a == null || (a == null ? void 0 : a.type) === "file") return;
  let t = {};
  if (s.value != null && (t = typeof s.value == "string" ? { mask: s.value } : { ...s.value }), s.arg != null) {
    const o = (r) => {
      const p = s.modifiers.unmasked ? r.unmasked : s.modifiers.completed ? r.completed : r.masked;
      c(s, p);
    };
    t.onMaska = t.onMaska == null ? o : Array.isArray(t.onMaska) ? [...t.onMaska, o] : [t.onMaska, o];
  }
  l.has(a) ? (u = l.get(a)) == null || u.update(t) : l.set(a, new L(a, t));
};
export {
  k as vMaska
};
//# sourceMappingURL=Maska_vue.js.map
